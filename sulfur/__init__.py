import numpy as np
import scipy
from scipy import constants
import ase.db
import ase.thermochemistry


def cm_to_hz(frequencies):
    from scipy.constants import c
    """Convert an array of frequencies from cm-1 to Hz (i.e. s-1)"""
    frequencies = np.array(frequencies)
    return frequencies * 100 * c # v (cm-1) * 100 (cm m-1) * c (m s-1)

def unpack_data(filename,ref_energy=0):
    """
    Get data for equilibrium solver from JSON file of ASE atoms objects with custom metadata.
    Assumptions: homonuclear system, no spin.
    
    Arguments
        filename: path to JSON file generated by Atomic Simulation Environment. (Other ASE-supported DB formats should work.)
            Required custom data dictionary - {frequencies:[freqs in cm-1], symmetry:[int rotational symmetry]}

    Returns
        labels: list of species names
        thermo: list of ASE ideal gas thermochemistry objects
             a: list of corresponding N values (number of atoms.)
             
    """
    c = ase.db.connect(filename)
    labels = []
    thermo = []
    a = []

    for N in range(1,10):         # Select by N for sensibly ordered output.
        for data_dict in c.select('S={0}'.format(N)):
            atoms = c.get_atoms(data_dict.id)
            vib_energies = cm_to_hz(np.array(data_dict.data.frequencies)) * constants.physical_constants['Planck constant in eV s'][0]
            species_thermo = ase.thermochemistry.IdealGasThermo(vib_energies, data_dict.data.geometry, 
                                       electronicenergy=atoms.get_total_energy() - ref_energy * N,
                                       atoms=atoms, symmetrynumber=data_dict.data.symmetry, spin=0)
            thermo.append(species_thermo)
            labels.append(data_dict.id)
            a.append(N)
    return labels, thermo, a

def reference_energy(db_file, units='eV', ref='expt'):
    """
    Calculate energy offset between ab initio calculations and reference state, using experimental formation enthalpy of S8.

    Arguments
        db_file: path to JSON file generated by Atomic Simulation Environment. (Other ASE-supported DB formats should work.)
                 Required custom data dictionary - {frequencies:[freqs in cm-1], symmetry:[int rotational symmetry]}
                 This dictionary must contain an entry with the key 'S8'.
        units:  Optional argument specifying energy units. Accepted values are 'eV' (default), 'jmol' (J mol-1) and 'kJmol' (kJ mol-1).
        ref:    Reference point. If 'expt', use experimental formation enthalpy. If 'S8', use computed S8 ground state energy as reference point. The former is recommended for convenient use with thermochemical literature, while the latter is recommended for use in ab initio studies.

    Returns
        ref_energy: Reference energy offset, per atom, to relate data to experimental formation energy for S8. Given in eV/atom by default.

    References
        The experimental formation enthalpy of S8 = 100.416 kJ mol-1: Chase (1997) NIST/JANAF Thermochemical Tables
    """
    from scipy.constants import N_A    
    DH_S8_expt_kJmol = 100.416 / 8

    c = ase.db.connect(db_file)
    s8 = c.get_atoms('S8')

    if ref=='S8':
        ref_energy = s8.get_total_energy() / 8.

    elif ref=='expt':    
        s8_data_dict = c.get_dict('S8')
        s8_vib_energies = cm_to_hz(np.array(s8_data_dict.data.frequencies)) * constants.physical_constants['Planck constant in eV s'][0]
        s8_thermo = ase.thermochemistry.IdealGasThermo(s8_vib_energies, s8_data_dict.data.geometry, 
                                               electronicenergy=s8.get_total_energy(),
                                               atoms=s8, symmetrynumber=s8_data_dict.data.symmetry, spin=0)
        if  units=='eV':
            DH_S8_expt_eV = DH_S8_expt_kJmol * 1E3 * constants.physical_constants['joule-electron volt relationship'][0] / N_A
            ref_energy = s8_thermo.get_enthalpy(298.15,verbose=False) / 8. - DH_S8_expt_eV
        elif units == 'jmol':
            ref_energy = s8_thermo.get_enthalpy(298.15,verbose=False) / 8. * constants.physical_constants['electron volt-joule relationship'][0] * N_A - DH_S8_expt_kJmol * 1E3
        elif units == 'kjmol':
            ref_energy = s8_thermo.get_enthalpy(298.15,verbose=False) / 8. * constants.physical_constants['electron volt-joule relationship'][0] * 1E-3 * N_A - DH_S8_expt_kJmol

    return ref_energy


def get_potentials(thermo,T=1000,P_ref=1E5,potential='free_energy'):
    """
    Calculate thermodynamic potential at given T, P for a range of ASE thermochemistry objects.

    Arguments
        thermo: iterable (e.g. list) of ASE thermochemistry objects (CrystalThermo, HarmonicThermo or IdealGasThermo)
        T: Temperature in degrees Kelvin
        P_ref: Pressure in Pa
        potential: string indicating desired potential. Accepted values: 'free_energy' (default), 'enthalpy'

    Returns
        energy_Jmol: Numpy array of free energies in J mol-1  corresponding to objects in iterable
    """
    from scipy import constants

    if potential == 'free_energy':
        energy_eV = [x.get_gibbs_energy(T,P_ref,verbose=False) for x in thermo]
    elif potential == 'enthalpy':
        energy_eV = [x.get_enthalpy(T,verbose=False) for x in thermo]
    else:
        raise Exception('Potential \"{0}\" not known'.format(potential))
    energy_Jmol = np.array(energy_eV) * constants.physical_constants['electron volt-joule relationship'][0] * constants.N_A
    return energy_Jmol

def mix_enthalpies(n, thermo, T):
    """
    Calculate enthalpy of ideal mixture by summing over components

    Arguments:
        n: Numpy array of molar fractions (atomic basis)
        thermo: iterable (e.g. list) if ASE thermochemistry objects corresponding to fractions in n

    Returns:
        enthalpy_Jmol: Scalar (float) enthalpy of mixture in J/mol
    """
    enthalpy_array = get_potentials(thermo, T, potential='enthalpy')
    return np.sum(n * enthalpy_array)

def solve_composition(a, potentials, P=1., T=500., verbose=False):
    """
    Calculate the equilibrium composition and free energy of a homonuclear gas mixture

    Arguments
        a: iterable of number of atoms in homonuclear molecule
            e.g. [2,8] if only considering S2, S8
        potentials: chemical potentials at reference pressure and given T of species studied, in J mol-1
        P: Pressure in units of reference pressure
            e.g. P=0.001 if study pressure is 1 mbar and reference pressure for potentials is 1 bar
        T: Temperature in K. This temperature must also be used when generating input potentials.
        verbose: Boolean flag. Print intermediate values.
    Returns
        n, mu_S:
            n: Amount of component in gas mixture, in units of mol molecule / mole atoms.
               To obtain units of atom%, n_atom_pc = [100 * a[i] * n_i for i, n_i in enumerate(n)]
            mu_S: Chemical potential of gas mixture in J mol-1
    """
    def vprint(*args):
        if verbose:
            for arg in args:
                print arg,
        else:
            pass

    from scipy.constants import R
        
    a = np.array(a)
    vprint("mu values: ", potentials, "J mol-1\n")
    vprint("RT = {0} J mol-1\n".format(R*T))
    vprint("mu / RT: ", np.array(potentials)/(R*T), '\n')
    # Form empty polynomial
    poly = [0]*(max(a)+1)
    poly[0] = -P
    for i, ai in enumerate(a):
        poly[ai] += np.exp((-potentials[i])/(R*T))
    poly.reverse()
    vprint("terms of polynomial: " + str(poly) + '\n')
        
    roots = scipy.roots(poly)
    good_root = False
    for root in roots:
        if root == root.real and root >= 0 :
            good_root = root
    
    # Root = exp(lambda/RT)
    lam = np.log(good_root.real) * R * T
    vprint("Lagrange multiplier = free energy/atom =  {0}\n".format(lam))
    mu_S = lam
    
    # Now to recover n values
    vprint("P=", P, "T=", T, "a=",a, '\n')

    phi = np.exp((a*lam - potentials)/(R*T))
    vprint(phi)
    b = 1.         # 1 mole of S atoms basis
    n = b * phi / (sum(a*phi))
    return n, mu_S

